"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderAstToHtml = void 0;
const html_entities_1 = require("html-entities");
function renderAstToHtml(tree, tocOptions) {
    const usedSlugs = [];
    const listClass = tocOptions.listClass !== '' ? ` class="${(0, html_entities_1.encode)(tocOptions.listClass)}"` : '';
    const itemClass = tocOptions.itemClass !== '' ? ` class="${(0, html_entities_1.encode)(tocOptions.itemClass)}"` : '';
    const linkClass = tocOptions.linkClass !== '' ? ` class="${(0, html_entities_1.encode)(tocOptions.linkClass)}"` : '';
    if (tree.children.length === 0) {
        return '';
    }
    let buffer = '';
    if (tree.level === 0 || isLevelSelected(tree.level, tocOptions.level)) {
        buffer += `<${(0, html_entities_1.encode)(tocOptions.listType) + listClass}>`;
    }
    buffer += tree.children.reduce((state, node) => {
        var _a, _b;
        const subNodesHtml = renderAstToHtml(node, tocOptions);
        if (isLevelSelected(node.level, tocOptions.level)) {
            const anchorContent = (0, html_entities_1.encode)((_b = (_a = tocOptions.format) === null || _a === void 0 ? void 0 : _a.call(tocOptions, node.name)) !== null && _b !== void 0 ? _b : node.name);
            const anchorId = generateUniqueSlug(node.name, tocOptions, usedSlugs);
            return state + `<li${itemClass}><a${linkClass} href="#${anchorId}">${anchorContent}</a>${subNodesHtml}</li>`;
        }
        else {
            return state + subNodesHtml;
        }
    }, '');
    if (tree.level === 0 || isLevelSelected(tree.level, tocOptions.level)) {
        buffer += `</${(0, html_entities_1.encode)(tocOptions.listType)}>`;
    }
    return buffer;
}
exports.renderAstToHtml = renderAstToHtml;
function isLevelSelected(level, levels) {
    return Array.isArray(levels) ? levels.includes(level) : level >= levels;
}
function generateUniqueSlug(slug, tocOptions, usedSlugs) {
    let index = tocOptions.uniqueSlugStartIndex;
    while (index < Number.MAX_VALUE) {
        const slugCandidate = tocOptions.slugify(slug, index);
        const slugWithIndex = index === 0 ? slugCandidate : `${slugCandidate}-${index}`;
        if (usedSlugs.includes(slugWithIndex)) {
            index += 1;
        }
        else {
            usedSlugs.push(slugWithIndex);
            return slugWithIndex;
        }
    }
    throw new Error('Too many slug with same name');
}
//# sourceMappingURL=toc-body-renderer.js.map